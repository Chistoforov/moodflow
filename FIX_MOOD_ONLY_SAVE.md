# Исправление: Сохранение записи с настроением без указания причин

## Проблема
Когда пользователь выбирал только настроение без указания причин (факторов), запись не сохранялась и день не отмечался в календаре. Для сохранения требовалось обязательно указать причину (работа, отношения и т.д.).

## Исправленные файлы

### 1. `/src/app/(user)/entry/[date]/page.tsx`

**Проблема:** При выборе настроения использовалось асинхронное обновление состояния React (`setMoodScore`), после чего сразу вызывалось сохранение с **старым** значением настроения.

**Решение:**
- Создана новая функция `saveMoodAndFactors()`, которая принимает явные значения настроения и факторов
- Обновлены обработчики клика на кнопки настроения и факторов для использования новой функции
- Теперь при выборе настроения сразу передается новое значение в функцию сохранения

```typescript
// Новая функция с явными параметрами
const saveMoodAndFactors = async (newMoodScore?: number | null, newFactors?: string[]) => {
  // ... сохранение с использованием переданных значений
}

// При клике на настроение
onClick={() => {
  setMoodScore(level.value)
  saveMoodAndFactors(level.value)  // Передаем новое значение напрямую
}}
```

### 2. `/src/app/(user)/calendar/page.tsx`

**Проблема:** Проверка наличия настроения использовала некорректное условие:
```typescript
const hasMood = entry && entry.mood_score
```
Это условие не работало корректно из-за "truthiness" в JavaScript.

**Решение:** Изменено на явную проверку на `null`:
```typescript
const hasMood = entry && entry.mood_score !== null
```

## Результат
Теперь пользователь может:
1. ✅ Выбрать только настроение без указания причин - запись сохраняется
2. ✅ День с настроением отображается в календаре
3. ✅ Опционально добавить причины (факторы) в любой момент
4. ✅ Все данные сохраняются корректно и отображаются в календаре

## Проверка
1. Откройте приложение
2. Перейдите к любой дате
3. Выберите настроение (не выбирая факторы)
4. Вернитесь в календарь
5. День должен быть отмечен выбранным настроением

## Технические детали
- API endpoint `/api/entries` уже корректно обрабатывал случаи с пустыми факторами
- База данных позволяет `factors` быть `null`
- Исправление было необходимо только на клиентской стороне

